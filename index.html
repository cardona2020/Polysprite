<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Logo as Vertex Points</title>
    <style>
      body { margin: 0; overflow: hidden; background: #000; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.skypack.dev/three@0.155.0';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(3, 3, 3);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Cube triangle tiling pattern (simplified version)
      const size = 1;
      const half = size / 2;
      const triangleHeight = Math.sqrt(3) / 2 * size;

      const positions = [];
      const colors = [];

      const faceOffsets = [
        new THREE.Vector3(0, 0, 0),     // Front
        new THREE.Vector3(0, 0, -1),    // Right
        new THREE.Vector3(0, 1, 0),     // Top
      ];

      const faceRotations = [
        new THREE.Euler(0, 0, 0),                     // Front
        new THREE.Euler(0, Math.PI / 2, 0),           // Right
        new THREE.Euler(-Math.PI / 2, 0, 0),          // Top
      ];

      const triangle = [
        [0, 0, 0],
        [size, 0, 0],
        [half, triangleHeight, 0]
      ];

      const colorPalette = [0xff77ff, 0x77ffff, 0x77ff77, 0xffff77];

      function createFace(origin, rotation) {
        const rotMatrix = new THREE.Matrix4().makeRotationFromEuler(rotation);
        const base = new THREE.Vector3().copy(origin);

        for (let x = 0; x < 3; x++) {
          for (let y = 0; y < 3; y++) {
            const offset = new THREE.Vector3(x * size, y * triangleHeight, 0);
            const triangleColor = new THREE.Color(colorPalette[Math.floor(Math.random() * colorPalette.length)]);

            for (const point of triangle) {
              const v = new THREE.Vector3(...point).add(offset).applyMatrix4(rotMatrix).add(base);
              positions.push(v.x, v.y, v.z);
              colors.push(triangleColor.r, triangleColor.g, triangleColor.b);
            }
          }
        }
      }

      // Create three visible cube faces
      for (let i = 0; i < 3; i++) {
        createFace(faceOffsets[i], faceRotations[i]);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true
      });

      const points = new THREE.Points(geometry, material);
      scene.add(points);

      function animate() {
        requestAnimationFrame(animate);
        points.rotation.y += 0.002;
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
